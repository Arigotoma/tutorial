{
  "version": "0.1.0",
  "summary": {
    "title": "Introduction",
    "description": "Курс для frontend разработчиков"
  },
  "config": {
    "testRunner": {
      "command": "npm run test --",
      "args": {
        "filter": "--grep",
        "tap": "--reporter=mocha-tap-reporter"
      },
      "directory": "coderoad"
    },
    "setup": {
      "commands": [
        "cd coderoad && npm install"
      ],
      "commits": [
        "da76f326b001bd56b421d9e0fc66b76566615549"
      ]
    },
    "repo": {
      "uri": "https://github.com/Arigotoma/tutorial.git",
      "branch": "1.1.1"
    },
    "dependencies": [
      {
        "name": "node",
        "version": ">=10"
      }
    ]
  },
  "levels": [
    {
      "id": "1",
      "title": "Введение в React",
      "summary": "Узнаем что такое React и создадим первое приложение.",
      "content": "**Для чего нужны библиотеки и фреймворки**\r\n\r\n> **Фреймворк** — это каркас для написания приложений.\r\n> Он определяет структуру, задаёт правила и предоставляет необходимый набор\r\n> инструментов для разработки.\r\n\r\nБиблиотеки и фреймворки упрощают программистам разработку ПО. Не нужно тратить\r\nвремя на решение типовых задач. Использование фреймворка со своими правилами\r\nорганизации кода позволяет избежать большинства проблем с которыми сталкиваются новички\r\n\r\nФреймворк — это скелет приложения, а задача разработчика оживить его, чтобы\r\nполучился рабочий механизм. Можно сказать что это шаблон приложения в котором есть\r\nбазовые функциональные и архитектурные решения.\r\n\r\nИспользование фреймворка безусловно ограничивает возможности программиста при\r\nразработке приложения, но фреймворков существует достаточное количество, чтобы вы\r\nмогли выбрать тот, что подходит именно для вашего приложения\r\n(~~ну или сделать свой собственный~~).\r\n\r\nПримеры фреймворков:\r\n   1. django — фреймворк для Python, нацеленный на скорость: готовые компоненты для\r\n      баз данных, рисования страниц, админок, окон входа на сайт, шаблонов и\r\n      множества других вещей\r\n   1. Ruby on Rails — тоже сильно ускоряет разработку сайтов.\r\n   1. Next.js — JavaScript фреймворк, созданный поверх React.js для создания веб-приложений.\r\n      Фреймворк был предназначен для решения проблемы React.js,\r\n      связанную с отрисовкой приложения на стороне сервера - SSR.\r\n      \r\n**Итого:**\r\n   - разработка ускоряется\r\n   - упрощается\r\n   - ограничивается правилами фреймворка\r\n\r\n> **Библиотека** — это готовый набор функций для решения определенной задачи,\r\n> например аутентификации.\r\n\r\nВ разработке приложений обычно используются не только фреймворки, но и библиотеки.\r\nДля примера возьмем решение системы линейных уравнений методом Гаусса.\r\nПути решения: \r\n   - Написать программу реализующую метод Гаусса\r\n   - Найти функции для манипуляций матрицами в библиотеке\r\n   - Найти готовое решение \r\n   - Воспользоваться онлайн-калькулятором\r\n\r\nПойдя по пути собственного решения мы потратим довольно много времени на реализацию\r\nи отладку приложения.\r\n\r\nЕсли найти библиотеку для взаимодействия с матрицами мы упростим себе задачу,\r\nв том что совершим меньше ошибок при работе с матрицей и сократим время разработки.\r\n\r\nКогда мы найдем готовое решение, то нам нужно будет просто передать данные в\r\nправильном формате, затратим минимальное время.\r\n\r\nВоспользовавшись сторонним сервисом мы не только сохраним свое время, но и\r\nне придется ничего вычислять (использовать ресурсы компьютера\\компании),\r\nпросто сделать запрос со входными данными на нужный сервис и дождаться ответа.\r\n\r\nКак видно из примера, библиотеки также помогают сохранить время и ресурсы.\r\nПодобные инструменты можно использовать более свободно, единственным ограничением\r\nявляется интерфейс взаимодействия.\r\nОдним из таких инструментов является библиотека **React.js**.\r\n\r\n**Что такое React**\r\n> **React** — это декларативная JavaScript библиотека для\r\n> создания пользовательских интерфейсов. Она позволяет вам собирать сложный\r\n> UI из маленьких изолированных кусочков кода, называемых «компонентами».\r\n\r\n**Почему React**\r\nReact подходит для разработки как больших, так и маленьких проектов.\r\nВ MVC модели React &ndash; это View.\r\nНам как frontend разработчикам большего и не надо.\r\n\r\nПо сути React это интерфейс разработчика для более простого взаимодействия с браузером.\r\nОперации применяемые через JavaScript и HTML чаще всего будут более дорогими в исполнении,\r\nчем при работе через React. Библиотека собирает все необходимые изменения и применяет\r\nих более оптимальным способом.\r\n\r\nБлагодаря популярности библиотеки существует огромное количество готовых решений,\r\nчто также упрощает процесс разработки приложения.\r\n\r\n![alt-количество использований react][/coderoad/img/react-libs.png]\r\n\r\nReact достаточно универсальный механизм, его можно использовать для построения \r\nприложения на сервере, в браузере и на мобильных устройствах.\r\nПодход к разработке приложения на React &ndash; декларативный, то есть приложение &ndash;\r\nзаранее известный набор состояний и переходов между этими состояниями.\r\n\r\n![alt-декларативный подход][declarative]\r\n\r\nДекларативный подход сокращает код и делает его понятным.\r\n\r\nReact пропагандирует при построении приложения использовать композицию\r\nкомпонентов, то есть приложение &ndash; набор компонентов.\r\n\r\n***Не используйте наследование***.\r\n\r\nКомпозиция позволяет решить все те же задачи, что и наследование,\r\nно при этом взаимодействие частей приложения становится более прозрачным.\r\n\r\n![alt-сравнение подходов][comparison]\r\n\r\nJSX синтаксис React приложений очень удобен и понятен разработчикам никогда не\r\nвстречавшим его ранее, так как он очень похож на HTML.\r\nПриложение представляет собой JS код с вкраплениями HTML-подобного синтаксиса и\r\nвозможностью вставки JS выражений внутрь \"HTML\".\r\n\r\n```jsx\r\nconst header = text ? <h1>{text}</h1> : null;\r\n\r\nconst vdom = (\r\n  <div>\r\n    {header}\r\n     <div> Hello world! </div>\r\n  </div>\r\n);\r\n```\r\n\r\nПоддержкой библиотеки занимается Facebook, при разработке сотрудники взаимодействую с\r\nразработчиками браузеров, тем самым постоянно улучшая свой продукт.\r\nТак как у React'a есть довольно большое сообщество, то найти ответ на интересующий\r\nвас вопрос не составит труда.\r\n\r\n**Первое приложение**\r\n\r\nЧто нужно для начала работы с React",
      "steps": [
        {
          "id": "1.1",
          "content": "Необходимо установить последнюю LTS версию [Node.js]",
          "hints": [
            "This is a hint to help people through the test",
            "Second hint for 1.1, don't worry if the hints don't show up yet"
          ],
          "setup": {
            "commits": [
              "abe7348c5ad757c4d53e1e41a390ee76da98661c"
            ]
          }
        },
        {
          "id": "1.2",
          "content": "Создаем приложение React. Запустим в консоли следующую команду:\r\n\r\n```bash\r\nnpx create-react-app my-app --template typescript\r\n```",
          "setup": {
            "commits": [
              "19c1631ec28d001047e84cb7979355634d950f96"
            ]
          },
          "solution": {
            "commits": [
              "736757689335cdc2c96a8dbda58a17b06b904df8"
            ]
          }
        },
        {
          "id": "1.3",
          "content": "Заходим в папку приложения\r\n\r\n```bash\r\ncd my-app\r\n```\r\n\r\nУдаляем в папке **/src** все файлы и создаем index.tsx\r\nСделаем \"Hello World\"\r\n\r\n```tsx\r\n// index.tsx\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(\r\n  <h1>Привет, мир!</h1>,\r\n  document.getElementById('root')\r\n);\r\n```",
          "setup": {
            "commits": [
              "f52f2b4ce146160979eb7a9ddbeaacfd341631de"
            ]
          },
          "solution": {
            "commits": [
              "d57f466a0a284a1757ca88b4bb27ad5b47d92343"
            ]
          }
        },
        {
          "id": "1.4",
          "content": "Сохраним все что сделали и запустим приложение:\r\n\r\n```bash\r\nnpm start\r\n```\r\n\r\nКоманда запустит сервер для разработки, преобразует ваши файлы и\r\n   автоматически откроет окно с браузером полученного приложения.\r\n\r\n![alt-Hello world][hello-world]\r\n   \r\n   Теперь можно вносить изменения в файл index.tsx и они автоматически\r\n   будут показываться в окне браузера.",
          "setup": {
            "commits": [
              "527a761c22158ad44f351d9c7d5a50d9e8513c2c"
            ]
          },
          "solution": {
            "commits": [
              "f9b4e0fd78c4a96161da8f7501601058781cc601"
            ]
          }
        }
      ]
    },
    {
      "id": "2",
      "title": "JSX",
      "summary": "Узнаем что такое jsx",
      "content": "JSX — расширение языка JavaScript.\r\nJSX напоминает язык шаблонов, наделённый силой JavaScript.\r\n\r\n```jsx\r\nconst element = <h1>Привет, мир!</h1>;\r\n```\r\n\r\n**Что такое JSX?**\r\n\r\nReact исходит из принципа, что логика рендеринга неразрывно связана с прочей\r\nлогикой UI: с тем, как обрабатываются события, как состояние изменяется во времени и\r\nкак данные готовятся к отображению.\r\nВместо того, чтобы искусственно разделить технологии, помещая разметку и логику\r\nв разные файлы, React разделяет ответственность с помощью слабо связанных единиц,\r\nназываемых «компоненты», которые содержат и разметку, и логику.\r\n\r\nReact можно использовать и без JSX, но большинство людей ценит его за наглядность\r\nпри работе с UI, живущем в JavaScript-коде.\r\nПомимо этого, JSX помогает React делать сообщения об ошибках и предупреждениях понятнее.\r\nПокажет вложенность компонента в приложении, например:\r\n\r\n![alt-ошибка в компоненте react][error-example]\r\n\r\n**Встраивание выражений в JSX**\r\n\r\nВ следующем примере мы объявляем переменную name и затем используем её внутри JSX,\r\nобрамляя фигурными скобками:\r\n\r\n```jsx\r\nconst name = 'Иван-Царевич';\r\nconst element = <h1>Здравствуй, {name}!</h1>;\r\n\r\nReactDOM.render(\r\n  element,\r\n  document.getElementById('root')\r\n);\r\n```\r\n\r\nJSX допускает использование любых корректных JavaScript-выражений внутри фигурных\r\nскобок. Например, ```2 + 2```, ```user.firstName``` и ```formatName(user)```\r\nявляются допустимыми выражениями.\r\n\r\nВ примере ниже мы встраиваем результат вызова JavaScript-функции ```formatName(user)```\r\nв элемент ```<h1>```:\r\n\r\n```jsx\r\nfunction formatName(user) {\r\n  return user.firstName + ' ' + user.lastName;\r\n}\r\n\r\nconst user = {\r\n  firstName: 'Марья',\r\n  lastName: 'Моревна'\r\n};\r\n\r\nconst element = (\r\n  <h1>\r\n    Здравствуй, {formatName(user)}!\r\n  </h1>\r\n);\r\n\r\nReactDOM.render(\r\n  element,\r\n  document.getElementById('root')\r\n);\r\n```\r\n\r\nЧтобы улучшить читаемость, мы разбили JSX на несколько строк. В таких случаях,\r\nхотя это и не обязательно, мы советуем заключать всё выражение целиком в круглые\r\nскобки, чтобы избежать проблем, связанных с автоматической вставкой точек с запятой.\r\n\r\n**Использование JSX в внутри JS выражений**\r\n\r\nПосле компиляции каждое JSX-выражение становится обычным вызовом JavaScript-функции,\r\nрезультат которого — объект JavaScript.\r\n\r\nИз этого следует, что JSX можно использовать внутри выражений if и циклов for,\r\nприсваивать переменным, передавать функции в качестве аргумента и возвращать из\r\nфункции.\r\n\r\n**В JSX-выражении обязателен корневой элемент.**\r\n\r\n```jsx\r\nfunction getGreeting(user) {\r\n  if (user) {\r\n    return <h1>Здравствуй, {formatName(user)}!</h1>;\r\n  }\r\n  return <h1>Здравствуй, незнакомец.</h1>;\r\n}\r\n```\r\n\r\n***JSX представляет собой объекты***\r\n\r\nВ старых версиях React (&leq; 17) при сборке приложения JSX элементы преобразуются в вызовы\r\n```React.createElement()```.\r\nНачиная с React 17 используется обновленное преобразование JSX элементов с целью увеличения\r\nпроизводительности\r\n\r\nСледующие два примера кода эквивалентны между собой:\r\n```jsx\r\nconst element = (\r\n  <h1 className=\"greeting\">\r\n    Привет, мир!\r\n  </h1>\r\n);\r\n```\r\n```jsx\r\n// old versions\r\nconst element = React.createElement(\r\n  'h1',\r\n  {className: 'greeting'},\r\n  'Привет, мир!'\r\n);\r\n\r\n// react 17\r\nimport {jsx} from 'react';\r\nconst element = jsx(\r\n  'h1',\r\n  {className: 'greeting', children: 'Привет, мир!'}\r\n);\r\n```\r\n\r\n```React.createElement()``` проводит некоторые проверки с целью выявить баги в коде,\r\nно главное — создаёт объект похожий на такой:\r\n\r\n```js\r\n// Примечание: этот код несколько упрощён.\r\nconst element = {\r\n  type: 'h1',\r\n  props: {\r\n    className: 'greeting',\r\n    children: 'Привет, мир!'\r\n  }\r\n};\r\n```\r\n\r\nЭти объекты называются React-элементами. Можно сказать, что они описывают результат,\r\nкоторый мы хотим увидеть на экране.\r\nReact читает эти объекты и использует их, чтобы конструировать и поддерживать DOM.\r\n\r\n***Компоненты React должны находиться в области видимости***\r\n\r\n***(React older versions)***\r\nПоскольку JSX компилируется в вызов ```React.createElement```, библиотека React должна\r\nвсегда быть в области видимости вашего JSX-кода.\r\n\r\n**В React после 17 версии** импорт происходит автоматически во время сборки приложения,\r\n**импортировать React вручную не нужно**.\r\n\r\nК примеру, в данном коде оба импорта являются необходимыми, даже если на ```React``` и\r\n```CustomButton``` нет прямых ссылок из JavaScript:\r\n\r\n```jsx\r\nimport React from 'react';\r\nimport CustomButton from './CustomButton';\r\n\r\nfunction WarningButton() {\r\n  // return React.createElement(CustomButton, {color: 'red'}, null);\r\n  return <CustomButton color=\"red\" />;\r\n}\r\n```\r\n\r\n***Использование атрибутов JSX***\r\n\r\nЧтобы использовать строковый литерал в качестве значения атрибута, используются\r\nкавычки:\r\n\r\n```jsx\r\nconst element = <div tabIndex=\"0\"></div>;\r\n```\r\n\r\nЕсли же в значении атрибута требуется указать JavaScript-выражение, то на помощь\r\nприходят фигурные скобки:\r\n\r\n```jsx\r\nconst element = <img src={user.avatarUrl}></img>;\r\n```\r\n\r\nНе ставьте кавычек вокруг фигурных скобок, когда используете JavaScript-выражение\r\nв значении атрибута. Следует либо применить кавычки (для строковых литералов),\r\nлибо фигурные скобки (для выражений), но не то и другое вместе.\r\n\r\n***Различия в атрибутах***\r\n\r\nЕсть ряд атрибутов, которые по-разному работают в React и HTML:\r\n\r\n***className***\r\n\r\nЧтобы указать класс CSS, используйте атрибут ```className```.\r\nЭто относится ко всем обычным элементам DOM и SVG, таким как ```<div>```, ```<a>```\r\nи т. д.\r\n\r\nЕсли вы используете React с веб-компонентами (что встречается редко), используйте\r\nвместо этого атрибут ```class```.\r\n\r\n***dangerouslySetInnerHTML***\r\n\r\nСвойству ```innerHTML``` в DOM браузера соответствует ```dangerouslySetInnerHTML```\r\nв React.\r\nКак правило, вставка HTML из кода рискованна, так как можно случайно подвергнуть\r\nваших пользователей атаке межсайтового скриптинга.\r\nТаким образом, вы можете вставить HTML непосредственно из React используя\r\n```dangerouslySetInnerHTML``` и передать объект с ключом ```__html```,\r\nчтобы напомнить себе, что это небезопасно. Например:\r\n\r\n```jsx\r\nfunction createMarkup() {\r\n  return {__html: 'Первый &middot; Второй'};\r\n}\r\n\r\nfunction MyComponent() {\r\n  return <div dangerouslySetInnerHTML={createMarkup()} />;\r\n}\r\n```\r\n\r\nТем не менее его можно использовать для взаимодействия с внешними библиотеками\r\nи фреймворками\r\n\r\n```jsx\r\nclass MarkdownEditor extends React.Component {\r\n    \r\n  getRawMarkup() {\r\n    const md = new Remarkable();\r\n    return { __html: md.render('Привет, **мир**!') };\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"MarkdownEditor\">\r\n        <label htmlFor=\"markdown-content\">\r\n          Что-то в формате Markdown\r\n        </label>\r\n        <div\r\n          className=\"content\"\r\n          dangerouslySetInnerHTML={this.getRawMarkup()}\r\n        />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nReactDOM.render(\r\n  <MarkdownEditor />,\r\n  document.getElementById('root')\r\n);\r\n```\r\n\r\n***style***\r\n\r\nАтрибут style принимает JavaScript-объект со свойствами в camelCase вместо CSS-строк.\r\nТакой подход повышает эффективность и защищает от XSS. Например:\r\n\r\n```jsx\r\nconst divStyle = {\r\n  color: 'blue',\r\n  backgroundImage: 'url(' + imgUrl + ')',\r\n};\r\n\r\nfunction HelloWorldComponent() {\r\n  return <div style={divStyle}>Привет, мир!</div>;\r\n}\r\n```\r\n\r\nReact автоматически добавит суффикс «px» к свойствам стилей с числовым значением.\r\nЕсли вы хотите использовать единицы измерения, отличные от «px», укажите значение в\r\nвиде строки с желаемой единицей измерения. Например:\r\n\r\n```jsx\r\n// Результат: '10px'\r\n<div style={{ height: 10 }}>\r\n  Привет, мир!\r\n</div>\r\n\r\n// Результат: '10%'\r\n<div style={{ height: '10%' }}>\r\n  Привет, мир!\r\n</div>\r\n```\r\n\r\nОднако не все свойства стилей преобразуются в пиксельные строки. Некоторые из них\r\nостаются без единиц (например, zoom, order, flex).\r\n\r\n***value***\r\n\r\nАтрибут value поддерживается компонентами ```<input>```, ```<select>``` и ```<textarea>```.\r\nОн устанавливает значение компонента.\r\nЭто полезно для создания управляемых компонентов.\r\n```defaultValue``` — это неуправляемый эквивалент, который устанавливает значение\r\nкомпонента во время первого монтирования.\r\n\r\n\r\n***Использование дочерних элементов в JSX***\r\n\r\nЕсли тег пуст, то его можно сразу же закрыть с помощью /> точно так же, как и в XML:\r\n\r\n```jsx\r\nconst element = <img src={user.avatarUrl} />;\r\n```\r\n\r\nНо JSX-теги могут и содержать дочерние элементы:\r\n\r\n```jsx\r\nfunction getGreeting(user) {\r\n    if (user) {\r\n        return <h1>Здравствуй, {formatName(user)}!</h1>;\r\n    }\r\n    return <h1>Здравствуй, незнакомец.</h1>;\r\n}\r\n\r\nconst element = (\r\n  <div>\r\n      {getGreeting()}\r\n      <h2>Рады вас видеть.</h2>\r\n  </div>\r\n);\r\n```\r\n\r\nЧасто это бывает полезно при рендере списка JSX-выражений произвольной длины.\r\nНапример, эта запись рендерит HTML-список:\r\n\r\n```jsx\r\nfunction Item(props) {\r\n  return <li>{props.message}</li>;\r\n}\r\n\r\nfunction TodoList() {\r\n  const todos = ['закончить документацию', 'отправить пулреквест', 'снова напомнить Дэну про ревью'];\r\n  return (\r\n    <ul>\r\n      {todos.map((message) => <Item message={message} />)}\r\n    </ul>\r\n  );\r\n}\r\n```\r\n\r\nJavaScript-выражения могут быть использованы вместе с другими типами дочерних компонентов.\r\nОни могут рассматриваться как альтернатива шаблонным строкам:\r\n\r\n```jsx\r\nfunction Hello(props) {\r\n  return <div>Привет, {props.addressee}!</div>;\r\n}\r\n```\r\n\r\n***Логические значения, null и undefined игнорируются***\r\n\r\nЗначения ```false```, ```null```, ```undefined``` и ```true``` — валидные дочерние компоненты.\r\nПросто они не рендерятся. Эти JSX-выражения будут рендерить одно и то же:\r\n\r\n```jsx\r\n<div />\r\n\r\n<div></div>\r\n\r\n<div>{false}</div>\r\n\r\n<div>{null}</div>\r\n\r\n<div>{undefined}</div>\r\n\r\n<div>{true}</div>\r\n```\r\n\r\nЭтот подход может быть полезным для рендера по условию.\r\nВот пример, где JSX рендерит <Header />, если showHeader равняется true:\r\n\r\n```jsx\r\n<div>\r\n  {showHeader && <Header />}\r\n  <Content />\r\n</div>\r\n```\r\n\r\nЕсть один нюанс в том, что React будет рендерить «ложные» (falsy) значения, такие как число 0.\r\nКод ниже ведёт себя не так, как вы могли ожидать, так как 0 будет отображён, если массив props.messages пуст:\r\n\r\n```jsx\r\n<div>\r\n  {props.messages.length &&\r\n    <MessageList messages={props.messages} />\r\n  }\r\n</div>\r\n```\r\n\r\nЧтобы исправить это, убедитесь что выражение перед оператором && всегда является boolean:\r\n```jsx\r\n<div>\r\n  {props.messages.length > 0 &&\r\n    <MessageList messages={props.messages} />\r\n  }\r\n</div>\r\n```\r\n\r\nИ наоборот, если вы хотите, чтобы такие значения как false, true, null или undefined отрисовались,\r\nто сначала вы должны преобразовать их в строку:\r\n\r\n```jsx\r\n<div>\r\n  Моя переменная JavaScript - {String(myVariable)}.\r\n</div>\r\n```\r\n\r\n***React.Fragment***\r\n\r\nКомпонент ```React.Fragment``` позволяет возвращать несколько элементов без\r\nсоздания дополнительного корневого элемента DOM:\r\n\r\n```jsx\r\nconst element = (\r\n    <React.Fragment>\r\n      Какой-то текст.\r\n      <h2>Заголовок</h2>\r\n    </React.Fragment>\r\n  );\r\n// или сокращенно\r\nconst element = (\r\n    <>\r\n        Какой-то текст.\r\n        <h2>Заголовок</h2>\r\n    </>\r\n);\r\n```\r\n\r\nВы также можете использовать его сокращённый синтаксис ```<></>```.\r\n\r\n**JSX предотвращает атаки, основанные на инъекции кода**\r\n\r\nДанные, введённые пользователем, можно безопасно использовать в JSX:\r\n\r\n```jsx\r\nconst title = response.potentiallyMaliciousInput;\r\n// Этот код безопасен:\r\nconst element = <h1>{title}</h1>;\r\n```\r\n\r\nПо умолчанию React DOM экранирует все значения, включённые в JSX перед тем как\r\nотрендерить их. Это гарантирует, что вы никогда не внедрите чего-либо,\r\nчто не было явно написано в вашем приложении. Всё преобразуется в строчки,\r\nперед тем как быть отрендеренным.\r\nЭто помогает предотвращать атаки межсайтовым скриптингом (XSS).\r\n\r\n[error-example]: ./2.%20JSX/error_example.png",
      "steps": [
        {
          "id": "2.1",
          "setup": {
            "files": [
              "index.tsx"
            ],
            "commits": []
          },
          "content": "Add the DOCTYPE",
          "hints": [
            "Add `<!DOCTYPE html>` at the top of `index.html` and save the file"
          ]
        }
      ]
    }
  ]
}